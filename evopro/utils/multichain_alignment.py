from biopandas.pdb import PandasPdb
import numpy as np
from itertools import permutations
import pandas as pd
import copy
from collections import OrderedDict

def calculate_rmsd(coords1, coords2):
    """Calculate RMSD between two sets of coordinates."""
    diff = coords1 - coords2
    return np.sqrt(np.mean(np.sum(diff * diff, axis=1)))

def kabsch_align(P, Q):
    """
    Kabsch algorithm for optimal rotation matrix.
    P and Q are coordinate sets of equal length.
    """
    # Center the points
    P_cent = P - P.mean(axis=0)
    Q_cent = Q - Q.mean(axis=0)
    
    # Compute covariance matrix
    H = P_cent.T @ Q_cent
    
    # Singular value decomposition
    U, S, Vt = np.linalg.svd(H)
    
    # Ensure right-handed coordinate system
    d = np.linalg.det(Vt.T @ U.T)
    if d < 0:
        Vt[-1,:] *= -1
        
    # Calculate optimal rotation matrix
    R = Vt.T @ U.T
    
    # Calculate translation
    t = Q.mean(axis=0) - (R @ P.mean(axis=0))
    
    return R, t

def transform_coordinates(coords, R, t):
    """Apply rotation matrix and translation to coordinates."""
    coords = coords.astype(float)
    try:
        return (R @ coords.T).T + t
    except:

        raise ValueError("Error in transformation. Check that the two PDBs have the same number of ca atoms.")

def get_ca_coordinates(pdb_df, chain_id):
    """Extract CA coordinates for alignment calculation."""
    ca_mask = (pdb_df['chain_id'] == chain_id) & (pdb_df['atom_name'] == 'CA')
    return pdb_df.loc[ca_mask, ['x_coord', 'y_coord', 'z_coord']].values.astype(float)

def apply_transformation_to_atoms(pdb_df, R, t):
    """Apply transformation to all atoms in a pdb."""

    coords = pdb_df.loc[:,['x_coord', 'y_coord', 'z_coord']].values.astype(float)
    new_coords = transform_coordinates(coords, R, t)
    
    # Update coordinates with proper formatting
    pdb_df.loc[:, 'x_coord'] = new_coords[:, 0]
    pdb_df.loc[:, 'y_coord'] = new_coords[:, 1]
    pdb_df.loc[:, 'z_coord'] = new_coords[:, 2]
    
    return pdb_df

def format_pdb_line(atom_info):
    """Format a single PDB line according to standard PDB format."""
    record_type = str(atom_info['record_name']).strip()
    atom_num = int(atom_info['atom_number'])
    atom_name = str(atom_info['atom_name']).strip()
    alt_loc = str(atom_info['alt_loc']).strip() if pd.notna(atom_info['alt_loc']) else ''
    res_name = str(atom_info['residue_name']).strip()
    chain_id = str(atom_info['chain_id']).strip()
    res_num = int(atom_info['residue_number'])
    insertion = str(atom_info['insertion']).strip() if pd.notna(atom_info['insertion']) else ''
    x = float(atom_info['x_coord'])
    y = float(atom_info['y_coord'])
    z = float(atom_info['z_coord'])
    occupancy = float(atom_info['occupancy']) if pd.notna(atom_info['occupancy']) else 1.0
    temp_factor = float(atom_info['b_factor']) if pd.notna(atom_info['b_factor']) else 0.0
    segment = str(atom_info['segment_id']).strip() if pd.notna(atom_info['segment_id']) else ''
    element = str(atom_info['element_symbol']).strip() if pd.notna(atom_info['element_symbol']) else atom_name[0]
    charge = str(atom_info['charge']).strip() if pd.notna(atom_info['charge']) else ''
    
    # Format according to PDB standard
    return (f"{record_type:<6}{atom_num:>5} {atom_name:<4}{alt_loc:1}{res_name:<3} "
            f"{chain_id:1}{res_num:>4}{insertion:1}   "
            f"{x:>8.3f}{y:>8.3f}{z:>8.3f}"
            f"{occupancy:>6.2f}{temp_factor:>6.2f}      "
            f"{segment:<4}{element:>2}{charge:<2}")

def get_chain_atoms(df, chain_id):
    """Get all atoms for a specific chain, sorted by residue and atom number."""
    chain_mask = df['chain_id'] == chain_id
    return df[chain_mask].sort_values(['residue_number', 'atom_number'])

def write_pdb(pdb_obj, output_path):
    """Write PDB file with proper formatting."""
    with open(output_path, 'w') as f:
        # Write REMARK about alignment
        f.write("REMARK   Generated by Structure Alignment Script\n")
        
        # Process chains one at a time
        chains = pd.unique(pdb_obj.df['ATOM']['chain_id'])
        current_atom_num = 1
        
        for chain in chains:
            # Write ATOM records for this chain
            chain_atoms = get_chain_atoms(pdb_obj.df['ATOM'], chain)
            for _, atom in chain_atoms.iterrows():
                atom = atom.copy()
                atom['atom_number'] = current_atom_num
                f.write(format_pdb_line(atom) + '\n')
                current_atom_num += 1
            
            # Write TER record for this chain
            if not chain_atoms.empty:
                last_atom = chain_atoms.iloc[-1]
                f.write(f"TER   {current_atom_num:>4}      {last_atom['residue_name']} "
                       f"{chain:1}{int(last_atom['residue_number']):>4}\n")
                current_atom_num += 1
        
        # Write HETATM records if they exist
        if 'HETATM' in pdb_obj.df and len(pdb_obj.df['HETATM']) > 0:
            for _, atom in pdb_obj.df['HETATM'].iterrows():
                atom = atom.copy()
                atom['atom_number'] = current_atom_num
                f.write(format_pdb_line(atom) + '\n')
                current_atom_num += 1
        
        # Write END record
        f.write("END\n")
        
def create_1d_array(coords):
    """Create a 1D array from an OrderedDict of 1D arrays."""
    new_coords = []
    for c in coords:
        if len(c) == 0:
            continue
        new_coords.extend(coords[c])
    new_coords = np.array(new_coords)
    return new_coords

def multichain_permutation_alignment(pdb1, pdb2, output_path=None):
    """
    Perform multichain permutation alignment between two PDB structures.
    Returns the best alignment RMSD, chain mapping, and optionally writes aligned structure.
    """
    # Load PDB structures
    # pdb1 = PandasPdb().read_pdb(pdb1_path)
    # pdb2 = PandasPdb().read_pdb(pdb2_path)
    
    # Create a copy for the aligned structure
    aligned_pdb = copy.deepcopy(pdb1)
    
    # Get unique chain IDs
    chains1 = pd.unique(pdb1.df['ATOM']['chain_id'])
    chains2 = pd.unique(pdb2.df['ATOM']['chain_id'])
    
    if len(chains1) != len(chains2):
        raise ValueError("PDB structures have different numbers of chains")
    
    # Extract CA coordinates for each chain
    coords1 = OrderedDict()
    coords2 = OrderedDict()
    for chain in chains1:
        coords1[chain] = get_ca_coordinates(pdb1.df['ATOM'], chain)
    for chain in chains2:
        coords2[chain] = get_ca_coordinates(pdb2.df['ATOM'], chain)
    
    c2 = create_1d_array(coords2)
    
    # Try all possible chain permutations
    best_rmsd = float('inf')
    best_mapping = None
    best_transformations = {}
    
    best_R, best_t = None, None
    for perm in permutations(chains2):
        perm_coords1 = OrderedDict()
        
        for p in perm:
            perm_coords1[p.lower()]=coords1[p]
            
        c1 = create_1d_array(perm_coords1)
            
        if len(c1) != len(c2):
            continue
        
        R, t = kabsch_align(c1, c2)
        aligned_coords = transform_coordinates(c1, R, t)
        rmsd = calculate_rmsd(aligned_coords, c2)
        
        if rmsd < best_rmsd:
            best_rmsd = rmsd
            best_R, best_t = R, t
            best_mapping = dict(zip(chains1, perm))
    
    # Apply transformations to all atoms
    aligned_pdb.df['ATOM'] = apply_transformation_to_atoms(
        aligned_pdb.df['ATOM'], best_R, best_t
        )
    if 'HETATM' in aligned_pdb.df and len(aligned_pdb.df['HETATM']) > 0:
        aligned_pdb.df['HETATM'] = apply_transformation_to_atoms(
            aligned_pdb.df['HETATM'], best_R, best_t
            )
    
    # Write aligned structure if output path is provided
    if output_path:
        write_pdb(aligned_pdb, output_path)
    
    return best_rmsd, best_mapping, aligned_pdb

def main():
    """Example usage of the multichain alignment function."""
    
    path = "/work/users/a/m/amritan/evopro_tests/mh_f3_105/test/"
    pdb1_path = path + "test1.pdb"
    pdb2_path = path + "test2.pdb"
    output_path = path + "aligned_test.pdb"
    
    pdb1 = PandasPdb().read_pdb(pdb1_path)
    pdb2 = PandasPdb().read_pdb(pdb2_path)
    
    rmsd, mapping, aligned_pdb = multichain_permutation_alignment(
        pdb1, pdb2, output_path
    )
    
    print(f"Best alignment RMSD: {rmsd:.2f} Ã…")
    print("\nChain mapping:")
    for chain1, chain2 in mapping.items():
        print(f"Structure 1 Chain {chain1} -> Structure 2 Chain {chain2}")
    
    atom_count = len(aligned_pdb.df['ATOM'])
    hetatm_count = len(aligned_pdb.df['HETATM']) if 'HETATM' in aligned_pdb.df else 0
    print(f"\nOutput structure contains:")
    print(f"ATOM records: {atom_count}")
    print(f"HETATM records: {hetatm_count}")
    print(f"\nAligned structure written to: {output_path}")

if __name__ == "__main__":
    main()